@page "/world/{WorldId}"
@using System.Numerics
@using Ab4d.SharpEngine.Cameras
@using Ab4d.SharpEngine.Common
@using Ab4d.SharpEngine.Core
@using Ab4d.SharpEngine.Lights
@using Ab4d.SharpEngine.SceneNodes
@using Ab4d.SharpEngine.Transformations
@using Ab4d.SharpEngine.Utilities
@using FE3.VoxelRenderer
@using FE3.VoxelRenderer.Utils
@using FE3.VoxelRenderer.VoxelWorld
@using Colors = Ab4d.SharpEngine.Common.Colors
@inject FE3.Api.WorldApi WorldApi

<MudContainer MaxWidth="MaxWidth.False" Class="pa-6">
    <MudPaper Class="pa-3" Elevation="1">
        <MudStack Spacing="2">
            <MudText Typo="Typo.h6">World Streaming Test</MudText>

            <MudStack Row="true" Spacing="2" AlignItems="AlignItems.Center">
                <MudText Typo="Typo.body2">WorldId:</MudText>
                <MudChip T="string">@WorldId</MudChip>
                <MudDivider Vertical="true" Class="mx-2" />

                <MudText Typo="Typo.body2">Player:</MudText>
                <MudChip T="string">
                    X @_playerPos.X.ToString("0.00"), Z @_playerPos.Z.ToString("0.00")
                </MudChip>


                <MudText Typo="Typo.body2">Chunk:</MudText>
                <MudChip T="string">
                    @_playerChunk.X, @_playerChunk.Y
                </MudChip>

                <MudText Typo="Typo.body2">Loaded:</MudText>
                <MudChip T="string">@_loadedCount</MudChip>

                @if (_error != null)
                {
                    <MudChip T="string" Color="Color.Error">@_error</MudChip>                }
            </MudStack>

            <MudGrid Spacing="2">
                <MudItem xs="12" sm="6" md="3">
                    <MudText Typo="Typo.caption">Load radius (chunks)</MudText>
                    <MudSlider T="int" Min="0" Max="12" Step="1"
                               Value="@_loadRadius"
                               ValueChanged="@(v => _loadRadius = v)" />
                </MudItem>

                <MudItem xs="12" sm="6" md="3">
                    <MudText Typo="Typo.caption">Move step</MudText>
                    <MudSlider T="float" Min="0.25f" Max="8f" Step="0.25f"
                               Value="@_moveStep"
                               ValueChanged="@(v => _moveStep = v)" />
                </MudItem>

                <MudItem xs="12" sm="6" md="3">
                    <MudText Typo="Typo.caption">Camera distance</MudText>
                    <MudSlider T="float" Min="5f" Max="150f" Step="1f"
                               Value="@_cameraDistance"
                               ValueChanged="OnCameraDistanceChanged"
                               Disabled="@(!_ready)" />
                </MudItem>

                <MudItem xs="12" sm="6" md="3">
                    <MudText Typo="Typo.caption">Tick ms</MudText>
                    <MudSlider T="int" Min="50" Max="1000" Step="50"
                               Value="@_tickMs"
                               ValueChanged="OnTickMsChanged" />
                </MudItem>
            </MudGrid>

            <MudStack Row="true" Spacing="1" AlignItems="AlignItems.Center">
                <MudButton Variant="Variant.Outlined" OnClick="Reset" Disabled="@(!_ready)">Reset</MudButton>

                <MudDivider Vertical="true" Class="mx-2" />

                <MudButton Variant="Variant.Filled" OnClick="() => Move(0, -_moveStep)" Disabled="@(!_ready)">Forward (-Z)</MudButton>
                <MudButton Variant="Variant.Filled" OnClick="() => Move(0,  _moveStep)" Disabled="@(!_ready)">Back (+Z)</MudButton>
                <MudButton Variant="Variant.Filled" OnClick="() => Move(-_moveStep, 0)" Disabled="@(!_ready)">Left (-X)</MudButton>
                <MudButton Variant="Variant.Filled" OnClick="() => Move( _moveStep, 0)" Disabled="@(!_ready)">Right (+X)</MudButton>
            </MudStack>
        </MudStack>
    </MudPaper>

    <MudPaper Class="pa-2 mt-3 world-scene-root" Elevation="1">
        <div class="scene-host">
            <SharpEngineSceneView @ref="_view"
                                  CanvasWidth="1100"
                                  CanvasHeight="650"
                                  style="width:100%; height:650px;" />
        </div>
        
        @if (!_ready)
        {
            <MudStack Class="pa-4">
                <MudProgressCircular Indeterminate="true" />
            </MudStack>
        }
    </MudPaper>
</MudContainer>

@code
{
    [Parameter] public string WorldId { get; set; } = null!;

    SharpEngineSceneView _view = null!;
    TargetPositionCamera? _camera;

    VoxelWorld _world;
    GpuImage? _diffuseGpuImage;

    readonly Dictionary<Int2, MeshModelNode> _rendered = new();
    CancellationTokenSource? _cts;
    Task? _loopTask;

    bool _ready;
    string? _error;

    Vector3 _playerPos = new(0, 0, 0);
    Int2 _playerChunk;

    int _loadRadius = 2;
    float _moveStep = 4f;

    int _tickMs = 150;

    float _cameraDistance = 70f;
    const float _defaultHeading = 35;
    const float _defaultAttitude = -45;

    int _loadedCount;

    protected override void OnAfterRender(bool firstRender)
    {
        if (!firstRender) return;

        InitScene();

        _ready = false;
        _view.SceneViewInitialized += OnSceneViewInitialized;
    }

    async void OnSceneViewInitialized(object? sender, EventArgs e)
    {
        try
        {
            // Texture atlas used by GreedyVoxelModel.BuildMesh
            _diffuseGpuImage = await TextureLoader.CreateTextureAsync("Atlas.png", _view.Scene);

            // World loader: fetch chunk -> deserialize UnmanagedVoxelModel
            _world = new VoxelWorld(async (chunk, ct) =>
            {
                await using var s = await WorldApi.GetChunkAsync(WorldId, chunk.X, chunk.Y, ct);

                using var ms = new MemoryStream();
                await s.CopyToAsync(ms, ct);

                return UnmanagedVoxelModel.Deserialize(ms.ToArray());
            });

            _cts = new CancellationTokenSource();
            _loopTask = TickLoopAsync(_cts.Token);

            _ready = true;
            StateHasChanged();
        }
        catch (Exception ex)
        {
            _error = ex.Message;
            StateHasChanged();
        }
    }

    void InitScene()
    {
        var scene = _view.Scene;
        var view = _view.SceneView;

        view.BackgroundColor = Colors.LightSkyBlue;
        scene.SetAmbientLight(0.25f);
        scene.Lights.Add(new DirectionalLight(new Vector3(-1, -0.6f, -0.2f)));

        _camera = new TargetPositionCamera
        {
            Heading = _defaultHeading,
            Attitude = _defaultAttitude,
            Distance = _cameraDistance,
            TargetPosition = new Vector3(0, 0, 0),
            ShowCameraLight = ShowCameraLightType.Never
        };

        view.Camera = _camera;
    }

    async Task TickLoopAsync(CancellationToken ct)
    {
        while (!ct.IsCancellationRequested)
        {
            try
            {
                await UpdateStreamingAsync(ct);
            }
            catch (OperationCanceledException) { }
            catch (Exception ex)
            {
                _error = ex.Message;
            }

            await InvokeAsync(StateHasChanged);

            try
            {
                await Task.Delay(_tickMs, ct);
            }
            catch (OperationCanceledException) { }
        }
    }

    async Task UpdateStreamingAsync(CancellationToken ct)
    {
        if (_world == null || _camera == null)
            return;

        _playerChunk = VoxelWorld.WorldToChunk(_playerPos);
        _camera.TargetPosition = new Vector3(_playerPos.X, 0, _playerPos.Z);

        int r = _loadRadius;

        // NOTE: "for now do not unload anything" -> we only add new chunks, never remove.
        for (int dz = -r; dz <= r; dz++)
        for (int dx = -r; dx <= r; dx++)
        {
            var chunk = new Int2(_playerChunk.X + dx, _playerChunk.Y + dz);

            if (!_world.IsChunkLoaded(chunk))
                await _world.LoadChunkAsync(chunk, ct);

            if (!_rendered.ContainsKey(chunk))
            {
                var mesh = _world.RenderChunk(chunk, _diffuseGpuImage);
                
                // Place the chunk mesh at world position (chunk origin)
                mesh.Transform = new StandardTransform
                {
                    TranslateX = chunk.X * VoxelWorld.ChunkSize,
                    TranslateY = 0,
                    TranslateZ = chunk.Y * VoxelWorld.ChunkSize
                };

                _view.Scene.RootNode.Add(mesh);
                _rendered.Add(chunk, mesh);
            }
        }

        _loadedCount = _rendered.Count;
    }

    void Move(float dx, float dz)
    {
        _playerPos.X += dx;
        _playerPos.Z += dz;
    }

    void Reset()
    {
        _playerPos = new Vector3(0, 0, 0);
        _cameraDistance = 70f;

        if (_camera != null)
        {
            _camera.Heading = _defaultHeading;
            _camera.Attitude = _defaultAttitude;
            _camera.Distance = _cameraDistance;
            _camera.TargetPosition = new Vector3(0, 0, 0);
        }
    }

    void OnCameraDistanceChanged(float v)
    {
        _cameraDistance = v;
        if (_camera != null) _camera.Distance = v;
    }

    void OnTickMsChanged(int v)
    {
        _tickMs = v;
    }

    void ClearSceneRoot()
    {
        _view.Scene.RootNode.DisposeWithAllChildren(
            disposeMeshes: true,
            disposeMaterials: true);

        _rendered.Clear();
        _loadedCount = 0;
    }

    public void Dispose()
    {
        try
        {
            _cts?.Cancel();
        }
        catch { }

        try
        {
            ClearSceneRoot();
        }
        catch { }

        try
        {
            _world?.Dispose();
        }
        catch { }

        try
        {
            _view?.Dispose();
        }
        catch { }

        _cts?.Dispose();
    }
}
